<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins自动化安装部署-权限配置（三）]]></title>
    <url>%2F2019%2F02%2F10%2FJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[权限配置 系统管理里面选择Manage and Assign Roles，来配置Jenkins的相关权限。 Manage Roles ：包括全局角色和项目角色 Assign Roles ：分配全局和项目角色 分配全局角色 分配项目角色 配置完成只有拥有Jenkins分配到权限的人才可以构建项目操作。 构建日志 项目构建历史里点击控制台输出即可查看当前项目构建的过程、更新了哪些文件以及服务器部署过程，便于快速的定位问题以及代码错误的文件名称。 在当前构建系统中可以查看到所有依赖的环境变量。 变更记录可以快速定位到某个开发提交了哪个错误文件导致的部署失败问题。 部署问题Tomcat应用更新时，把新的WAR包放到webapps目录下，Tomcat就会自动把原来的同名webapp删除，并把WAR包解压，运行新的 webapp。 有时候Tomcat并不能把旧的webapp完全删除，通常会留下WEB-INF/lib下的某个jar包，必须关闭Tomcat才能删除，这就导致自动部署失败。解决方法是在元素中增加一个属性antiResourceLocking=”true” antiJARLocking=”true”，默认是”false”。这样就可以热部署了。这两个参数就是配置Tomcat的资源锁定和Jar包锁定策略。1&lt;Context antiResourceLocking="true"&gt; 注：以上问题是直接通过tomcat内部账号连接部署的时候会发生的问题，如果直接通过scp文件上传打包到服务器不会出现上述问题。 如果部署后出现缓存问题，修改的配置文件等没有生效，手动删除Jenkins工作空间的war文件。 注：如果配置文件进行修改后，而已经部署到Jenkins的workspace中的war没有清理，继续构建的话，Jenkins会默认保留已构建的war，而不会将最新的文件关联到nexus中。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动化安装部署-环境配置（二）]]></title>
    <url>%2F2019%2F02%2F10%2FJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过上述安装步骤，jenkins已经成功安装到所在服务器中，下面通过访问地址进入web页面操作。 打开浏览器输出：http://服务器IP地址:8888/ 打开url会出现一个配置Jenkins的登录密码的界面，设置一个密码，继续进入如下面界，选择建议安装的插件，进行安装，等待安装完毕。 安装成功之后，进入jenkins的主页面，开始新建job，也就是所谓的项目名，jenkins中的项目名字相当于实际项目的逻辑名称，与之对应存储在jenkins的workspaces下。 Global Tool Configuration 在系统管理-全局环境配置，可以配置系统所需要的JDK、ANT、GIT、MAVEN、GRADLE、DOCKER等环境变量。 其次在项目配置中的源码管理里选择当前项目的svn资源库相关配置。以便部署项目的时候直接会从SVN服务器更新编译到本地。 注：一定要加@HEAD是把你本机工作区的版本更新到服务器上最新版本，这样可以避免造成文件冲突导致的文件不可用问题。 在构建中选择方式：Invoke Ant，并选择之前配置的ant版本，此处不能为default。 可以通过编辑视图来添加相关文档说明，也可以复制启动Banner直接到视图里。 配置完成之后在项目列表就可以针对当前项目进行构建自动化部署操作。 至此基本环境配置和项目配置就结束了，开始配置并分配用户权限以及项目开发人员的访问权限。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动化安装部署-安装配置（一）]]></title>
    <url>%2F2019%2F02%2F10%2FJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Jenkins概述Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。Jenkins可以通过本机系统包Docker安装，甚至可以通过安装Java Runtime Environment的任何机器独立运行。 Jenkins特点 开源免费; 跨平台，支持所有的平台; master/slave支持分布式的build; web形式的可视化的管理页面; 安装配置超级简单; tips及时快速的帮助; 已有的200多个插件 系统要求 环境 说明 配置环境 JDK JDK1.5以上 JDK1.7 硬盘 无最低要求、根据实际项目大小适当即可。 80G 操作系统 Jenkins可以安装到主流的所有操作系统。 CentOS Java容器 WAR文件可以在支持 Servlet2.4/JSP2.0或更高版本的容器中运行 独立安装 代码库 支持SVN或者GIT等同步插件 （示例svn） svn 编译打包 支持Maven或ANT来自动构建（示例ant） ant 需求概述由于项目架构是SpringMVC，并没有使用Maven来构建，所以本文安装的Jenkins基于ant环境构建发布（也可以使用Maven），配置比较方便。 Ant安装1[root@localhost jenkins]# vi /etc/profile 在最后添加 123ANT_HOME=/usr/local/apache-ant-1.8.4PATH=$ANT_HOME/bin:$PATHexport ANT_HOME 完整的配置如下 123456789JAVA_HOME=/usr/local/jdk7JRE_HOME=/usr/local/jdk7/jreJENKINS_HOME=/var/lib/jenkinsMAVEN_HOME=/usr/local/apache-maven-3.5.0ANT_HOME=/usr/local/apache-ant-1.8.4PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$ANT_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH MAVEN_HOME ANT_HOME CLASSPATH JENKINS_HOMEexport LD_LIBRARY_PATH=/usr/apr/lib 注意：ANT的1.9到1.10版本均由jdk1.8版本编译支持，如果用的是jdk1.7，要下载ANT1.8版本。如果是远程进行ant构建需要下载一个jar包，Ant提供的Sshexec和scp任务，由$ANT_HOME/lib/ant-jsch.jar提供支持，但是同样你也要在http://www.jcraft.com/jsch/index.html下载一个依赖包jsch-0.1.24.jar(文件名因版本而不同)，jsch同样也是http://www.sourceforge.net下的一个项目。你需要把下载的jsch-0.1.24拷贝到$ANT_HOME/lib下 Jenkins安装支持war和本地安装两种方式（本文主要说明第二种方式） Jenkins下载地址1https://jenkins.io/index.html 默认情况下，最新版本和长期支持版本可供下载。过去的版本也可以下载。单击下载部分的长期支持版本选项。 Jenkins两种安装方式 Jenkins的war包下载后发布到Tomcat服务器的Webapps下即可配（比较简单） 用于Jenkins的RedHat Linux RPM软件包(第二种方式) 使用Jenkins官网提供的源下载Jenkins，服务器上面执行下面命令： 123[root@localhost jenkins]# sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo[root@localhost jenkins]# sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key[root@localhost jenkins]# sudo yum install jenkins 启动Jenkins 1[root@localhost jenkins]# service jenkins start/stop/restart jenkins的默认设置： Jenkins会随系统启动而启动。详情参照/etc/init.d/jenkins Jenkins会创建一个用户叫做jenkins, 如果你修改了user，则要修修改所属者：/var/log/jenkins,/var/lib/jenkins,/var/cache/jenkins 如果遇到问题，查看日志/var/log/jenkins/jenkins.log 配置文件/etc/sysconfig/jenkins 默认启用8080 （本文使用的是8888） 1[root@localhost jenkins]# vi /etc/sysconfig/jenkins 修改如下几个地方：1、JENKINS_USER=”root” 当前用户执行权限。2、JENKINS_JAVA_OPTIONS=”-Dhudson.util.ProcessTree.disable=true” 此处必须要改，防止在启动jenkins 的时候jenkins自动杀死衍生进程，导致服务器始终无法正常启动。3、JENKINS_PORT=”8888” 为了避免和Tomcat端口冲突，修改自己的端口。 安装后直接访问地址：1http://服务器IP地址:8888/]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql自动安装脚本]]></title>
    <url>%2F2019%2F02%2F10%2FMysql%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Mysql概述MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 执行过程由于频繁安装mysql添加用户配置权限以及编译初始化过程基本一致，所以可以直接编写shell文件来自动执行重复的工作。 mysql脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/bin/bash# 脚本 ：Mysql自动安装配置脚本# 说明 ：安装 mysql-5.6.32-linux-glibc2.5-x86_64.tar.gz on # 环境 ：Centos# 作者 ：Jackie.Yang# 编写日期：2016.09.20# 备份系统文件mv /etc/my.cnf /etc/my.cnf.bakcd /usr/local/cp ./e/my.cnf /etc/echo 解压缩...tar -zxvf mysql-5.6.32-linux-glibc2.5-x86_64.tar.gzsleep 15secho 解压完毕，进程等待...#修改安装名称mv mysql-5.6.32-linux-glibc2.5-x86_64 mysql#进去mysql根目录cd mysqlecho 添加用户groupadd mysqluseradd -g mysql mysqlecho 修改mysql所属用户组chown -R mysql:mysql /usr/local/mysqlecho 开始执行mysql安装。。。# mysql5.7之前版本初始化命令./scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql#mysql5.7的初始化命令# ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/dataecho 安装等待。。。sleep 15srm my.cnfcp ../m/my.cnf .chown -R mysql:mysql /usr/local/mysql/my.cnfcp support-files/mysql.server /etc/init.d/mysqldchmod +x /etc/init.d/mysqld#echo 添加mysql到系统服务#chkconfig --add mysqld #echo 添加mysql随机启动 #chkconfig mysqld oncd bin#service mysqld start | awk '&#123;print $3&#125;'service mysqld startecho 启动服务中...sleep 5s#判断字符串是否相等service mysqld start | awk '&#123;if("SUCCESS!"== $3) print "Mysql数据库启动成功！" &#125;' ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sockecho 初始化数据库配置...# 5.7数据会生成临时密码：如：XAcLpcVsd9/.；# 修改密码#SET PASSWORD = PASSWORD('123456');./mysql -uroot -e "use mysqlupdate user set password=password('123456') where user='root';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;flush privileges;quit"echo 配置成功，数据库用户：root； 密码：123456；exit;#service mysqld start | awk '&#123;if("SUCCESS!" != $3) print "Mysql数据库启动失败！" &#125;' 注：mysql5.7之前版本初始化配置表命令./scripts/mysql_install_db，mysql5.7的mysql_install_db命令是在bin目录下，并且建议用mysqld –initialize命令来执行初始化，此脚本针对Mysql5.6及以下版本，5.7等高版本需替换对应版本的初始化脚本。 复制修改好的my.cnf到 /etc/下，内容如下： 1234567891011121314151617[mysqld] socket=/tmp/mysql.sock user=mysql basedir = /usr/local/mysql datadir = /usr/local/mysql/data port = 3306 server_id = 121 log_bin = mysql_bin wait_timeout=31536000 interactive_timeout=31536000# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tengine安装和使用]]></title>
    <url>%2F2019%2F02%2F09%2FTengine%2F</url>
    <content type="text"><![CDATA[Tengine简介Tengine 作为淘宝Web服务器，是基于nginx的进行了订制开发和扩展，也解决了Nginx中upstream无法检查代理后端存活等众多不灵活的问题，本人正是由于此需求了解到了Tengine，并且完成了安装测试调试等一系列问题，最终部署生产应用。 Tengine发展Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。从2011年12月开始，Tengine成为一个开源项目。现在，它由Tengine团队开发和维护。Tengine团队的核心成员来自于淘宝、搜狗等互联网企业。 Tengine功能 继承Nginx-1.6.2的所有特性，兼容Nginx的配置； 动态模块加载（DSO）支持。加入一个模块不再需要重新编译整个Tengine； 支持SO_REUSEPORT选项，建连性能提升为官方nginx的三倍； 支持SPDY v3协议，自动检测同一端口的SPDY请求和HTTP请求； 流式上传到HTTP后端服务器或FastCGI服务器，大量减少机器的I/O压力； 更加强大的负载均衡能力，包括一致性hash模块、会话保持模块，还可以对后端的服务器进行主动健康检查，根据服务器状态自动上线下线，以及动态解析upstream中出现的域名； 输入过滤器机制支持。通过使用这种机制Web应用防火墙的编写更为方便； 支持设置proxy、memcached、fastcgi、scgi、uwsgi在后端失败时的重试次数； 动态脚本语言Lua支持。扩展功能非常高效简单； 支持管道（pipe）和syslog（本地和远端）形式的日志以及日志抽样； 支持按指定关键字(域名，url等)收集Tengine运行状态； 组合多个CSS、JavaScript文件的访问请求变成一个请求； 自动去除空白字符和注释从而减小页面的体积 自动根据CPU数目设置进程个数和绑定CPU亲缘性； 监控系统的负载和资源占用从而对系统进行保护； 显示对运维人员更友好的出错信息，便于定位出错机器； 更强大的防攻击（访问速度限制）模块； 更方便的命令行参数，如列出编译的模块列表、支持的指令等； 可以根据访问文件类型设置过期时间； Tengine下载地址 下载地址：http://tengine.taobao.org/download.html 也可以通过wget直接下载到指定服务器： wget http://tengine.taobao.org/download/tengine-2.1.0.tar.gz 本人使用的是tengine版本2.1.0，相对来说比较稳定。 Tengine环境依赖由于Tengine安装需要使用源代码自行编译，所以在安装前需要安装必要的编译工具： 1、PCRE PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx rewrite依赖于PCRE库，所以在安装Tengine前一定要先安装PCRE。 123456cd /usr/local/ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gz tar -zxvf pcre-8.42.tar.gz cd pcre-8.42 ./configure --prefix=/usr/local/pcre make &amp;&amp; make install 2、Zlib Zlib是提供资料压缩之用的函式库，当Tengine想启用GZIP压缩的时候就需要使用到Zlib 123456cd /usr/local/ wget http://zlib.net/zlib-1.2.11.tar.gz tar zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure --prefix=/usr/local/zlib make &amp;&amp; make install 3、jemalloc jemalloc是一个很好的内存管理工具，使用jemalloc可以更好的优化Tengine的内存管理。 123456cd /usr/local/ wget https://github.com/jemalloc/jemalloc/releases/download/5.0.1/jemalloc-5.0.1.tar.gz tar -zxvf jemalloc-5.0.1.tar.gz cd jemalloc-5.0.1 ./configure --prefix=/usr/local/jemalloc make &amp;&amp; make install 4、OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。安装OpenSSL主要是为了让tengine支持Https的访问请求。 123456cd /usr/local/ wget https://www.openssl.org/source/openssl-fips-2.0.16.tar.gz tar -zxvf openssl-fips-2.0.16 cd openssl-fips-2.0.16./config --prefix=/usr/local/openssl make &amp;&amp; make install 5、gcc yum install gcc gcc-c++ 注：源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(make install)。Configure是一个可执行脚本，它有很多选项，在待安装的源码路径下使用命令./configure –help输出详细的选项列表。其中–prefix选项是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较凌乱。如果配置–prefix，如：./configure –prefix=/usr/local/test，可以把所有资源文件放在/usr/local/test的路径中，不会杂乱。用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）。当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是make文件指定过uninstall。 以上依赖环境安装后的目录格式如下： 最后进入tengine目录执行： 12345678./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-pcre=/usr/local/pcre-8.42 --with-openssl=/usr/local/openssl --with-zlib=/usr/local/zlib --with-jemalloc=/usr/local/jemalloc make &amp;&amp; make install 由于以上安装过程过于麻烦，笔者使用了简化安装，yum安装依赖环境后，直接执行./configure 123456yum -y install gcc automake autoconf libtool make yum -y install pcre-develyum -y install openssl openssl-devel cd /usr/local/tengine-2.2.3./configuremake &amp;&amp; make install 启动tengine 第一种启动方式会默认加载nginx下的配置文件 ./nginx/sbin/nginx -s reload 第二种启动方式指定tengine的配置文件/usr/local/nginx/sbin/nginx -c /usr/local/tengine-2.2.3/conf/nginx.conf]]></content>
      <categories>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>Tengine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCat 配置详解]]></title>
    <url>%2F2018%2F12%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[MyCat是一款基于阿里开源产品Cobar而研发的开源数据库分库分表中间件（基于Java语言开发）。MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为N个小表，存储在后端MySQL服务器里或者其他数据库里。也可以这样理解：数据库是对底层存储文件的抽象，而Mycat是对数据库的抽象。 MyCat关键特性 支持SQL92标准 支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法 遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理 基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群 支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster 基于Nio实现，有效管理线程，解决高并发问题 支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页 支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join 支持通过全局表，ER关系的分片策略，实现了高效的多表join查询 支持多租户方案 支持分布式事务（弱xa） 支持XA分布式事务（1.6.5） 支持全局序列号，解决分布式下的主键生成问题 分片规则丰富，插件化开发，易于扩展 强大的web，命令行监控 支持前端作为MySQL通用代理，后端JDBC方式支持MySQL、PostgreSQL、Oracle、DB2、SQLServer、MongoDB、巨杉 支持密码加密 支持服务降级 支持IP白名单 支持SQL黑名单、sql注入攻击拦截 支持prepare预编译指令（1.6） 支持非堆内存(Direct Memory)聚合计算（1.6） 支持PostgreSQL的native协议（1.6） 支持mysql和oracle存储过程，out参数、多结果集返回（1.6） 支持zookeeper协调主从切换、zk序列、配置zk化（1.6） 支持库内分表（1.6） 集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版） MyCat的目标低成本的将现有的单机数据库和应用平滑迁移到“云”端，解决数据存储和业务规模迅速增长情况下的数据瓶颈问题。 MyCat的优势基于阿里开源的Cobar产品而研发，Cobar的稳定性、可靠性、优秀的架构和性能，以及众多成熟的使用案例使得MyCAT一开始就拥有一个很好的起点，站在巨人的肩膀上，能看到更远。 广泛吸取业界优秀的开源项目和创新思路，将其融入到MyCAT的基因中，使得MyCAT在很多方面都领先于目前其他一些同类的开源项目，甚至超越某些商业产品。 MyCAT背后有一只强大的技术团队，其参与者都是5年以上资深软件工程师、架构师、DBA等，优秀的技术团队保证了MyCAT的产品质量。 MyCAT并不依托于任何一个商业公司，因此不像某些开源项目，将一些重要的特性封闭在其商业产品中，使得开源项目成了一个摆设。 MyCat的架构 MyCAT使用MySQL的通讯协议模拟成一个MySQL服务器，并建立了完整的Schema（数据库）、Table （数据表）、User（用户）的逻辑模型，并将这套逻辑模型映射到后端的存储节点DataNode（MySQL Instance）上的真实物理库中，这样一来，所有能使用MySQL的客户端以及编程语言都能将MyCAT当成是MySQLServer来使用，不必开发新的客户端协议。 当MyCAT收到一个客户端发送的SQL请求时，会先对SQL进行语法分析和检查，分析的结果用于SQL路由，SQL路由策略支持传统的基于表格的分片字段方式进行分片，也支持独有的基于数据库E-R关系的分片策略，对于路由到多个数据节点（DataNode）的SQL，则会对收到的数据集进行“归并”然后输出到客户端。SQL执行的过程，简单的说，就是把SQL通过网络协议发送给后端的真正的数据库上进行执行，对于MySQL Server来说，是通过MySQL网络协议发送报文，并解析返回的结果，若SQL不涉及到多个分片节点，则直接返回结果，写入客户端的SOCKET流中，这个过程是非阻塞模式（NIO）。 DataNode是MyCAT的逻辑数据节点，映射到后端的某一个物理数据库的一个Database，为了做到系统高可用，每个DataNode可以配置多个引用地址（DataSource），当主DataSource被检测为不可用时，系统会自动切换到下一个可用的DataSource上，这里的DataSource即可认为是Mysql的主从服务器的地址。 MyCat的初始化 MyCat的逻辑库与任何一个传统的关系型数据库一样，MyCAT也提供了“数据库”的定义，并有用户授权的功能，下面是MyCAT逻辑库相关的一些概念： schema:逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。 table：表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode，这是通过表格的分片规则定义来实现的，table可以定义其所属的“子表(childTable)”，子表的分片依赖于与“父表”的具体分片地址，简单的说，就是属于父表里某一条记录A的子表的所有记录都与A存储在同一个分片上。 分片规则：是一个字段与函数的捆绑定义，根据这个字段的取值来返回所在存储的分片（DataNode）的序号，每个表格可以定义一个分片规则，分片规则可以灵活扩展，默认提供了基于数字的分片规则，字符串的分片规则等。 dataNode: MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上，一般来说，为了高可用性，每个DataNode都设置两个DataSource，一主一从，当主节点宕机，系统自动切换到从节点。 dataHost：定义某个物理库的访问地址，用于捆绑到dataNode上。 MyCAT目前通过配置文件的方式来定义逻辑库和相关配置： MYCAT_HOME/conf/schema.xml中定义逻辑库，表、分片节点等内容； MYCAT_HOME/conf/rule.xml中定义分片规则； MYCAT_HOME/conf/server.xml中定义用户以及系统相关变量，如端口等。 MyCat的核心配置解析 schema.xml相关参数说明： &lt;?xml version="1.0"?&gt; &lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt; &lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;!-- 定义一个MyCat的模式，逻辑数据库名称hsg_oa --&gt; &lt;!-- “checkSQLschema”：描述的是当前的连接是否需要检测数据库的模式 --&gt; &lt;!-- “sqlMaxLimit”：表示返回的最大的数据量的行数 --&gt; &lt;!-- “dataNode="dn1"”：该操作使用的数据节点是dn1的逻辑名称 --&gt; &lt;schema name="hsg_oa" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"/&gt; &lt;!-- 定义数据的操作节点 --&gt; &lt;!-- “dataHost="localhost1"”：定义数据节点的逻辑名称 --&gt; &lt;!-- “database="mldn"”：定义数据节点要使用的数据库名称 --&gt; &lt;dataNode name="dn1" dataHost="localhost1" database="hsg_oa" /&gt; &lt;!-- 定义数据节点，包括了各种逻辑项的配置 --&gt; &lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;!-- 配置真实MySQL与MyCat的心跳 --&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- 配置真实的MySQL的连接路径 --&gt; &lt;writeHost host="hostM1" url="192.168.1.128:3306" user="root" password="123456"&gt;&lt;/writeHost&gt; &lt;/dataHost&gt; &lt;/mycat:schema&gt; dataHost标签属性说明 balance:负载均衡类型0：不开启读写分离机制，所有读操作都发送到当前可用的writeHost上 1：全部的readHost与stand by writeHost参与select语句的负载均衡， 2：所有读操作都随机在writeHost、readHost上分发 3：所有读请求随机分发到writeHost对应的readHost执行，writeHost不负担读压力 writeType:负载均衡类型 0：所有写操作发送到配置的第一个writeHost，当第一个writeHost宕机时，切换到第二个writeHost，重新启动后以切换后的为准，切换记录在配置文件：dnindex.properties中 1：所有写操作都随发送到配置的writeHost 2：尚未实现 switchType:切换方式 -1：不自动切换1：自动切换（默认） 2：基于MySql主从同步的状态来决定是否切换 server.xml相关参数说明： &lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;system&gt; &lt;!-- 1为开启实时统计、0为关闭 如果使用Mycat-eye监控SQL则需要开启此项--&gt; &lt;code&gt;&lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt;&lt;/code&gt; &lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt; &lt;property name=&quot;useGlobleTableCheck&quot;&gt;0&lt;/property&gt; &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt; &lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt; &lt;property name=&quot;handleDistributedTransactions&quot;&gt;0&lt;/property&gt; &lt;!--off heap for merge/order/group/limit 1开启 0关闭 --&gt; &lt;property name=&quot;useOffHeapForMerge&quot;&gt;1&lt;/property&gt; &lt;!--单位为m--&gt; &lt;property name=&quot;memoryPageSize&quot;&gt;1m&lt;/property&gt; &lt;!--溢出文件缓冲区大小 单位为k--&gt; &lt;property name=&quot;spillsFileBufferSize&quot;&gt;1k&lt;/property&gt; &lt;property name=&quot;useStreamOutput&quot;&gt;0&lt;/property&gt; &lt;!--系统预留内存大小 单位为m--&gt; &lt;property name=&quot;systemReserveMemorySize&quot;&gt;384m&lt;/property&gt; &lt;!--是否采用zookeeper协调切换 --&gt; &lt;property name=&quot;useZKSwitch&quot;&gt;true&lt;/property&gt; &lt;!-- root 登录设置 --&gt; &lt;user name=&quot;root&quot;&gt; &lt;property name=&quot;password&quot;&gt;Hsg@123456&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;hsg_wx&lt;/property&gt; &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt; &lt;/user&gt; &lt;user name=&quot;user&quot;&gt; &lt;property name=&quot;password&quot;&gt;user&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;hsg_wx&lt;/property&gt; &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt; &lt;/user&gt; MyCat常用命令 ./mycat restart 重启服务 ./mycat pause 暂停 ./mycat status 查看启动状态 ./mycat start 启动 ./mycat stop 停止 mysql -uroot -p（账号密码） -h（所在机器IP） -P8066 -D（逻辑库名） 终端登录]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何更高效的管理原生微服务应用]]></title>
    <url>%2F2018%2F12%2F24%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%8E%9F%E7%94%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自从阿里重启Dubbo维护以来，其热度迅速蹿升，Github上的星标数已经达到了2.2万个之多，可谓中国开源软件界的明星产品。但是作为自家商业化输出的EDAS产品，却一直以来只能支持闭源的HSF微服务框架，对用户而言不能不说是一种遗憾。虽然以前也是可以支持Dubbo应用的，但却是以一种所谓的Dubbo over HSF来变相实现的，并不是真正无侵入的原生应用。现在这个担忧终于没有了，EDAS官方正式开始了商业化支持Dubbo的进程闲话少絮，我们先来构建一个简单的Dubbo应用，并将其部署到EDAS上面。根据这篇文档介绍的方法，我们来实现一个简单的Echo应用。此应用的能力是客户端通过HTTP接口获得一个字符串消息，然后将此消息发送给服务端，服务端接收到这个消息之后，再原封不动的回传给客户端，最终客户端将此回声信息打印出来，程序结束。 标 题标 题本文并不是一篇教程类文章，因此不会详细介绍该如何编写这样一个应用，只来关注一些重点内容。首先，除了依赖Dubbo库之外，还需要依赖一个EDAS提供的扩展库edas-dubbo-extension。该扩展库就是EDAS支持原生Dubbo应用的关键所在。 图1.edas-dubbo-extension依赖图1.edas-dubbo-extension依赖 除此之外，我们还需要将Dubbo配置文件中的registry参数设置为轻量级配置中心的地址。 标 注 按图 2.registry地址图2.registry地址 经过了这样的修改之后，我们的应用就可以原封不动的部署到EDAS上面了。 实际的部署过程与普通应用无异，应该是EDAS会自动判断该应用是否为原生Dubbo进而区分对待，因此熟悉EDAS的用户在这一点上不会碰到任何问题。部署完成以后在Provider和Consumer应用的服务列表里面，分别可以看到如下内容，说明服务启动正常。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到Github服务器]]></title>
    <url>%2F2018%2F12%2F24%2Fnew-Day%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。为了更加方便的实现本地到git服务器的部署同步问题，因此可以通过如下操作配置实现本地编写文章后，直接部署到Github服务器，通过Github域名来访问,达到快捷、高效、一劳永逸的效果。 配置文件修改_config.yml文件中对应的repo值如下 1234deploy:type: gitrepository: git@github.com:yangzhiwen911/yangzhiwen911.github.io.gitbranch: master 注：repository的值 即为github项目中的ssh地址，直接复制过来即可。 生成SSH git bash中配置name(git的用户名)和email（git的邮箱） 12git config --global user.name "yourname"git config --global user.email "youremail" 进入~目录，执行ssh-keygen，生成.ssh文件夹会有一对公钥和私钥,复制公钥内容到Github 1ssh-keygen -t rsa -C "youremail" #生成ssh对应key，直接输入回车并设置密码即可。 Github对应的ssh and key地址入口： 在gitbash中，查看是否成功 1ssh -T git@github.com 当出现你的Github用户名的时候，即为成功，可以进行下一步操作。 安装插件 在生成以及部署文章之前，需要安装一个插件，这样才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 最后执行部署： 12hexo dhexo s 至此，部署过程结束，可以直接通过http://yourname.github.io 网址查看你的个人博客了！ 部署问题 如果出现缺少模块等报错问题，直接使用hexo install 下载命令即可。 如果出现模板渲染等报错问题，需检查md文件是否有标签未闭合等语法问题。 命令大全 Hexo常用命令： 12345678910hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo version #查看hexo版本号hexo --debug #调试模式，输出所有日志信息hexo --safe #安全模式，禁用所有的插件和脚本hexo --silent #无日志输出模式hexo --config config-path #指定配置文件，代替默认的_config.yml Hexo缩略语： 12345hexo n == hexo new #创建一个新的blog页面hexo g == hexo generate #生成静态文件hexo s == hexo server #启动本地服务器hexo d == hexo deploy #部署网站项目hexo v == hexo version #hexo版本 Hexo复合命令： 1234hexo deploy -ghexo server -ghexo server -d (hexo s ) #启动本地服务器hexo generate -w #watch参数的缩写，source/_post中的md文件有改动，就会自动publish Hexo清除命令： 1hexo clean 注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
        <tag>Github</tag>
        <tag>ssh</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术栈梳理分享]]></title>
    <url>%2F2018%2F12%2F24%2FJackie-Yang%2F</url>
    <content type="text"><![CDATA[Java面试分析 结合底层实现原理梳理了一些面试点：]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
